var documenterSearchIndex = {"docs":
[{"location":"api/#AbnormalReturns-API","page":"API","title":"AbnormalReturns API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This package reexports StatsModels.jl and BusinessDays.jl. See those packages and their respective documentation for methods that they export.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Notable methods from StatsModels.jl:","category":"page"},{"location":"api/","page":"API","title":"API","text":"@formula","category":"page"},{"location":"api/","page":"API","title":"API","text":"Notable methods from BusinessDays.jl:","category":"page"},{"location":"api/","page":"API","title":"API","text":"advancebdays\nbdayscount\ntobday","category":"page"},{"location":"api/#Setting-Up-Data","page":"API","title":"Setting Up Data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MarketData","category":"page"},{"location":"api/#AbnormalReturns.MarketData","page":"API","title":"AbnormalReturns.MarketData","text":"function MarketData(\n    df_market,\n    df_firms;\n    date_col_market=:date,\n    date_col_firms=:date,\n    id_col=:permno,\n    valuecols_market=nothing,\n    valuecols_firms=nothing\n)\n\nArguments\n\ndf_market: A Tables.jl compatible source that stores market data, indexed by date.   The dates must be a unique set. The column name for the date column is specified   by the keyword argument \"datecolmarket\"\ndf_firms: A Tables.jl compatible source that stores firm data. Each firm must have a   unique set of dates. The column name for the date column is specified   by the keyword argument \"datecolfirms\" and the firm ID column is specified   by the keyword argument \"id_col\"\nvaluecols_market=nothing: If left as nothing, all other columns in df_market are   used as the value columns. These are the columns that are stored in the resulting   dataset. Otherwise a vector of Symbol or String specifying column names.\nvaluecols_firms=nothing: Same as above\nid_col=:permno: The column corresponding to the set of firm IDs in df_firms\n\nMarketData is the main data storage structure. Data is stored for each firm in a Dict, where the data itself is a NamedTuple (names corresponding to column names, such as \"ret\"), and the keys for the Dict corresponding to firm IDs. The MarketData struct also stores overall market data and a calendar of dates.\n\nAny firm data must have a corresponding market data date, so there cannot be a firm return if there is not a market return on that date.\n\nExample\n\ndf_firm = CSV.File(joinpath(data_dir, \"daily_ret.csv\"))\ndf_mkt = CSV.File(joinpath(data_dir, \"mkt_ret.csv\"))\ndf_mkt[!, :mkt] = df_mkt.mktrf .+ df_mkt.rf\nmkt_data = MarketData(\n    df_mkt,\n    df_firm\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Regression-Related-Methods","page":"API","title":"Regression Related Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"quick_reg\nBasicReg\nalpha\nbeta\nvar\nstd","category":"page"},{"location":"api/#AbnormalReturns.quick_reg","page":"API","title":"AbnormalReturns.quick_reg","text":"quick_reg(\n    data::TimelineTable{false},\n    f::FormulaTerm;\n    minobs::Real=0.8,\n    save_residuals::Bool=false\n)\n\nquick_reg(\n    data::IterateTimelineTable,\n    f::FormulaTerm;\n    minobs::Real=0.8,\n    save_residuals::Bool=false\n)\n\nCalculates a linear regression for the supplied data based on the formula (formula from StatsModels.jl). Unless the formula explicitly excludes the intercept (i.e., @formula(y ~ 0 + x)), an intercept is added.\n\nIf data is of the type IterateTimelineTable, then the formula is applied to each TimelineTable in an optimized way and returns a Vector{BasicReg}.\n\nArguments\n\nminobs::Real: The minimum number of observations to return a completed regression. If less than 1,   the value is used as a percentage relative to the total number of business days in the time period.   Therefore, the default of 0.8 corresponds to at least 80% of the business days over the time period have values.\nsave_residuals::Bool=false: Whether to save the residuals into BasicReg, This can have significant performance implications.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbnormalReturns.BasicReg","page":"API","title":"AbnormalReturns.BasicReg","text":"function BasicReg(\n    resp::AbstractVector{Float64},\n    pred::AbstractMatrix{Float64},\n    yname::String,\n    xnames::Vector{String},\n    f::FormulaTerm{L,R};\n    save_residuals::Bool=false,\n    minobs::Int=1\n)::BasicReg{L,R} where {L,R}\n\nArguments\n\nresp::AbstractVector{Float64}: The \"Y\" or response in a linear regression\npred::AbstractMatrix{Float64}: The \"X\" matrix in a linear regression\nyname::String: The name of the response variable\nxnames::Vector{String}: The names of the prediction variables\nf::FormulaTerm{L,R}: A StatsModels.jl formula, saved in the resulting struct\nsave_residuals::Bool=false: Whether or not to save the vector of residuals from   the regression. Note for large numbers of regressions this can significantly slow   down the speed\nminobs::Int=1: The minimum length of the response vector for the regression to   run. The regression will also not run if the length of the response vector is   less than or equal to the number of columns in the prediction matrix.\n\nBasicReg is an intentionally simplistic linear regression. It also attempts to produce a minimum number of allocations if views of vectors are passed.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbnormalReturns.alpha","page":"API","title":"AbnormalReturns.alpha","text":"alpha(rr::RegressionModel, coefname::String...=\"intercept\")\n\n\"alpha\" in respect to the the CAPM model, i.e., the intercept in the model. This is the alpha from the estimation period.\n\nThis function finds the position of the coefficient name provided, defaults to \"intercept\". If the coefname is not in the regression, then this function returns an error.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbnormalReturns.beta","page":"API","title":"AbnormalReturns.beta","text":"beta(rr::RegressionModel, coefname::String...=[\"mkt\", \"mktrf\", \"vwretd\", \"ewretd\"])\n\n\"beta\" in respect to the CAPM model, i.e., the coefficient on the market return minus the risk free rate. This is the beta from the estimation period.\n\nThis function finds the position of the coefficient name provided, defaults to several common market returns. If the coefname is not in the regression, then this function returns an error.\n\n\n\n\n\n","category":"function"},{"location":"api/#Calculation-Functions","page":"API","title":"Calculation Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"bhar\ncar\nbh_return","category":"page"},{"location":"api/#AbnormalReturns.bhar","page":"API","title":"AbnormalReturns.bhar","text":"bhar(\n    data::TimelineTable{Mssng, T, MNames, FNames},\n    firm_col=FNames[1],\n    mkt_col=MNames[1];\n    minobs=0.8\n) where {Mssng, T, MNames, FNames}\n\nbhar(\n    data::TimelineTable,\n    rr::RegressionModel;\n    minobs=0.8\n)\n\nbhar(\n    data::IterateTimelineTable{T, MNames, FNames},\n    firm_col=FNames[1],\n    mkt_col=MNames[1];\n    minobs=0.8\n) where {T, MNames, FNames}\n\nbhar(\n    data::IterateTimelineTable,\n    rrs::AbstractVector{<:BasicReg};\n    minobs=0.8\n)\n\nCalculates the difference between buy and hold returns (also referred to as geometric returns) for a firm and a benchmark. If a regression is passed, then the benchmark is based on the coefficients from that regression and the performance of the benchmarks in the regression. These are sometimes called Fama-French abnormal returns. Simple abnormal returns use a market index as the benchmark (such as the S&P 500 or a value weighted return of all firms).\n\nSimilar to constructing the regression, passing an IterateTimelineTable will return a Vector and uses a more optimized method.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbnormalReturns.car","page":"API","title":"AbnormalReturns.car","text":"car(\n    data::TimelineTable{Mssng, T, MNames, FNames},\n    firm_col=FNames[1],\n    mkt_col=MNames[1];\n    minobs=0.8\n) where {Mssng, T, MNames, FNames}\n\ncar(\n    data::TimelineTable,\n    rr::RegressionModel;\n    minobs=0.8\n)\n\ncar(\n    data::IterateTimelineTable{T, MNames, FNames},\n    firm_col=FNames[1],\n    mkt_col=MNames[1];\n    minobs=0.8\n) where {T, MNames, FNames}\n\ncar(\n    data::IterateTimelineTable,\n    rrs::AbstractVector{<:BasicReg};\n    minobs=0.8\n)\n\nCalculates the cumulative returns of a firm over a benchmark (through addition of each return). If a regression is passed, then the benchmark is based on the coefficients from that regression and the performance of the benchmarks in the regression. These are sometimes called Fama-French abnormal returns. Simple abnormal returns use a market index as the benchmark (such as the S&P 500 or a value weighted return of all firms).\n\nSimilar to constructing the regression, passing an IterateTimelineTable will return a Vector and uses a more optimized method.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbnormalReturns.bh_return","page":"API","title":"AbnormalReturns.bh_return","text":"Calculates the buy and hold returns (also called geometric return) for TimelineData. If an Integer is passed, then it is calculated based on the FIRMDATACACHE (for the integer provided), otherwise is calculated for the MARKETDATACACHE.\n\nThese functions treat missing returns in the period implicitly as a zero return.\n\n\n\n\n\n","category":"function"},{"location":"datastructure/#AbnormalReturns-Data-Structure","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"","category":"section"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"The key to the performance in this package is the underlying data structure. These rely on a combination of BusinessDays.jl and Tables.jl to provide fast access to slices of data based on dates.","category":"page"},{"location":"datastructure/#DataVector-(and-DataMatrix)","page":"AbnormalReturns Data Structure","title":"DataVector (and DataMatrix)","text":"","category":"section"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"DataVector\nDataMatrix","category":"page"},{"location":"datastructure/#AbnormalReturns.DataVector","page":"AbnormalReturns Data Structure","title":"AbnormalReturns.DataVector","text":"struct DataVector <: CalendarData\n    data::Vector{Float64}\n    missing_bdays::SparseVector{Bool, Int}\n    dates::ClosedInterval{Date}\n    calendar::MarketCalendar\n    function DataVector(data, missing_bdays, dates, calendar)\n        @assert length(data) == length(missing_bdays) == bdayscount(calendar, dates.left, dates.right) + 1 \"Data does not match length of dates or missings\"\n        new(data, missing_bdays, dates, calendar)\n    end\nend\n\nDataVector(data::AbstractVector, dates::ClosedInterval{Date}, cal::MarketCalendar)\n\nDataVector(data::AbstractVector, dates::AbstractVector{Date}, cal::MarketCalendar)\n\n\n\n\n\n","category":"type"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"These structures provide strongly typed data that is easy to slice based on a range of dates. The data is always stored as Float64, even though it accepts elements of type Missing. In storing the data, Missing values are converted to 0.0, and the missing_bdays is a SparseVector that is true when that value is missing. dates are the minimum and maximum dates for the data.","category":"page"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"Access to a DataVector or Matrix is through providing a ClosedInterval from IntervalSets.jl:","category":"page"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"data[Date(2018) .. Date(2019)]","category":"page"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"This will return a Vector or Matrix, depending on type.","category":"page"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"!!! Note     The data returned is always a Vector (or Matrix) of Float64, even if there was missing data in the original Vector. To truly get back to the original, you must combine the missing_bdays with the Vector.","category":"page"},{"location":"datastructure/#MarketData","page":"AbnormalReturns Data Structure","title":"MarketData","text":"","category":"section"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"    struct MarketData{T, MNames, FNames, N1, N2}\n        calendar::MarketCalendar\n        marketdata::NamedTuple{MNames, NTuple{N1, DataVector}} # column names as symbols\n        firmdata::Dict{T, NamedTuple{FNames, NTuple{N2, DataVector}}} # data stored by firm id and then by column name as symbol\n    end","category":"page"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"This struct is made up of a set of DataVector. The main purpose of this is to provide efficient storage of the underlying data.","category":"page"},{"location":"datastructure/#TimelineTable","page":"AbnormalReturns Data Structure","title":"TimelineTable","text":"","category":"section"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"TimelineTable","category":"page"},{"location":"datastructure/#AbnormalReturns.TimelineTable","page":"AbnormalReturns Data Structure","title":"AbnormalReturns.TimelineTable","text":"mutable struct TimelineTable{Mssng, T, MNames, FNames, N1, N2} <: Tables.AbstractColumns\n    parent::MarketData{T, MNames, FNames, N1, N2}\n    \"The current ID\"\n    id::T\n    \"Whether the functions return Vector{Union{Missing, Float64}} or Vector{Float64}\"\n    allow_missing::Type{AllowMissing{Mssng}}\n    \"Actual returnable dates that guarentees a square matrix made of the minimum and maximum of the DataVectors for this ID and set of columns\"\n    dates::ClosedInterval{Date}\n    \"Index of column names and any lags/leads\"\n    cols::DictIndex\n    \"missing days between the dates\"\n    missing_bdays::SparseVector{Bool, Int}\n    \"dates requested, which provides what data is automatically returned by functions\"\n    req_dates::ClosedInterval{Date}\nend\n\nThis type provides Tables.jl access to DataVectors.\n\nFunctions to update some values are:\n\nAbnormalReturns.update_id!: changes the id (which updates dates and missing_bdays)\nselect!: changes the cols (also updates dates and missing_bdays if cols is different)\nAbnormalReturns.update_dates!: changes req_dates (does not update anything else)\n\n\n\n\n\n","category":"type"},{"location":"#AbnormalReturns-Documentation","page":"Introduction","title":"AbnormalReturns Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides functionality for running firm-specific regressions commonly used to calculate abnormal stock returns (actual stock return minus a benchmark). These are common in event studies in finance and economics and often require running a large number of regressions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Most of the documentation is currently in the example.","category":"page"},{"location":"#Motivation","page":"Introduction","title":"Motivation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"When estimating abnormal returns, it is common to estimate how the firm's return typically responds during an estimation window and use those predicted results in an event window:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The exact length of the estimation and event windows varies, but are typically about 150 and 3-5, respectively. The estimation is typically is a linear regression of firm specific return on market-wide factors.","category":"page"},{"location":"#The-Problem","page":"Introduction","title":"The Problem","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"It is typical to estimate these for a large amount of firm events. For example, there are over 600,000 firm earnings announcements (when a firm announces bottom line earnings for a quarter) since 1990. Sometimes, it is also necessary to use multiple models, so it is possible to run run several million regressions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The typical method do do this is:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Join the market information to the firm specific information (which means repeating a lot of market information, which can be difficult depending on size of the datasets)\nDoing a range join based on the estimation window (this can again repeat a lot of information if the estimation windows overlap)\nAggregating the data\nRepeat the process to bring the estimated results into the event window.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The joins in these steps are especially costly. On a sample of 1 million firm events for 10,000 simulated firms, InMemoryDatasets.jl (the only Julia package I am aware of that can do a range join) took 68 seconds to complete the join in step 2. This is very fast compared to other methods (SAS takes over 7 minutes), but it also takes up a lot of space in memory (20+ GiB).","category":"page"},{"location":"#This-Package","page":"Introduction","title":"This Package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package uses a custom data structure to avoid repeating the data. It organizes the same data above in just under 20 seconds and is typically smaller in memory than the original datasets.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"After the data is ingested, it is easy to run regressions and use those estimated values in an event window. In a benchmark on those 1 million firm events, this package can run all the regressions in under 3 seconds. It is also not necessary to do another range join for the event window, meaning that part takes less than a second.","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package would not be possible without BusinessDays.jl, which is used for all of the date operations in this package and StatsModels.jl, which provides an incredible @formula macro and the functionality that comes with that.","category":"page"},{"location":"example/#AbnormalReturns-Example","page":"Example","title":"AbnormalReturns Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"As a quick example:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"data_dir = joinpath(\"..\", \"..\", \"test\", \"data\") # hide\nusing CSV, DataFramesMeta, Dates, AbnormalReturns\n\ndf_firm = CSV.File(joinpath(data_dir, \"daily_ret.csv\")) |> DataFrame\ndf_mkt = CSV.File(joinpath(data_dir, \"mkt_ret.csv\")) |> DataFrame\ndf_mkt[!, :mkt] = df_mkt.mktrf .+ df_mkt.rf\ndf_events = CSV.File(joinpath(data_dir, \"firm_earnings_announcements.csv\")) |> DataFrame\nmkt_data = MarketData(\n    df_mkt,\n    df_firm\n)\ndf_events = @chain df_events begin\n    @rtransform(\n        :est_start = advancebdays(mkt_data.calendar, :ea, -120),\n        :est_end = advancebdays(mkt_data.calendar, :ea, -2),\n        :event_start = advancebdays(mkt_data.calendar, :ea, -1),\n        :event_end = advancebdays(mkt_data.calendar, :ea, 1),\n    )\n    @transform(:reg = quick_reg(mkt_data[:permno, :est_start .. :est_end], @formula(ret ~ mkt + smb + hml)))\n    @transform(\n        :bhar_reg = bhar(mkt_data[:permno, :event_start .. :event_end], :reg),\n        :bhar_simple = bhar(mkt_data[:permno, :event_start .. :event_end], \"ret\", \"mkt\"),\n        :car_reg = car(mkt_data[:permno, :event_start .. :event_end], :reg),\n        :car_simple = car(mkt_data[:permno, :event_start .. :event_end], \"ret\", \"mkt\"),\n    )\n    @rtransform(\n        :std = std(:reg),\n        :var = var(:reg),\n        :total_ret = bh_return(mkt_data[:permno, :event_start .. :event_end], \"ret\"),\n        :total_mkt_ret = bh_return(mkt_data[:permno, :event_start .. :event_end], \"mkt\"),\n    )\n    select(Not([:est_start, :est_end, :event_start, :event_end, :reg]))\n    # columns eliminated to save space:\n    select(Not([:car_reg, :car_simple, :var, :total_mkt_ret]))\nend\nshow(df_events) # hide","category":"page"},{"location":"example/#Data","page":"Example","title":"Data","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"For the basic data, this uses the files in the test folder of this package (\"test\\data\"). The \"dailyret.csv\" file is a selection of firm returns, while \"mktret.csv\" includes the average market return along with some Fama-French factor returns, you can download similar Fama-French data from here and stock market data from AlphaVantage.jl or WRDSMerger.jl (requires access to the WRDS database).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The firm data uses \"Permno\" to identify a stock. This package will work with other identifiers, as long as the identifier-date pair is unique.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"data_dir = joinpath(\"..\", \"..\", \"test\", \"data\") # hide\nusing CSV, DataFramesMeta, Dates, AbnormalReturns","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Load the firm data:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_firm = CSV.File(joinpath(data_dir, \"daily_ret.csv\")) |> DataFrame\nshow(df_firm) # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"and the market data:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_mkt = CSV.File(joinpath(data_dir, \"mkt_ret.csv\")) |> DataFrame\ndf_mkt[!, :mkt] = df_mkt.mktrf .+ df_mkt.rf\nshow(df_mkt) # hide","category":"page"},{"location":"example/#Arranging-and-Accessing-the-Data","page":"Example","title":"Arranging and Accessing the Data","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Next, load the data into a MarketData object:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"mkt_data = MarketData(\n    df_mkt,\n    df_firm;\n    id_col=:permno,# default\n    date_col_firms=:date,# default\n    date_col_market=:date,# default\n    valuecols_firms=[:ret],# defaults to nothing, in which case\n    # all columns other than id and date are used\n    valuecols_market=[:mkt, :smb, :hml, :umd]# defaults to\n    # nothing, in which case all columns other than date are used\n)\nshow(mkt_data) # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"note: Note\nFor performance, especially when loading large datasets of firm data, it is best to make sure the firm dataframe is presorted by ID then Date.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This object rearranges the data so it can be quickly accessed later. The mkt_data now contains 3 things:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"A BusinessDays.jl calendar that exactly matches the days loaded in the market data.\nEach column of the df_mkt stored\nEach column of the df_firm stored in a Dict for each firm.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Data is accessed on a by firm basis. For example, the \"Permno\" for Oracle (ORCL) is 10104:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"orcl_data = mkt_data[10104]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"You can also request a specific range of dates and columns using EllipsisNotation.jl:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"orcl_data = mkt_data[10104, Date(2020) .. Date(2020, 6, 30), [:ret, :mkt, lag(:mkt)]]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The dates requested only matter for what is output, internally all data is still stored. In this way, the parameters are largely a \"view\" into the mkt_data object, allowing for quick updating. For example, changing the dates is just:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"AbnormalReturns.update_dates!(orcl_data, Date(2020, 7, 1) .. Date(2020, 7, 5))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"There are similar functions for update_id! (changing the firm ID) and select! (changing the columns).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Finally, by default, returned data is not missing. This is to make the regressions faster/easier later, since missing data does not work for those. You can change between allowing or not allowing missing data with allowmissing and dropmissing:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"no_missings = mkt_data[18428, Date(2019, 3, 28) .. Date(2019, 4, 5)]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"with_missings = allowmissing(no_missings)","category":"page"},{"location":"example/#Estimating-Regressions","page":"Example","title":"Estimating Regressions","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The main goal of this package is quickly running regressions for firm events. The example used here is a firm's earnings announcement. Starting with one example, Oracle announced its Q3 2020 earnings on 2020-9-10. Calculating abnormal returns typically follows three steps:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Estimate how the firm typically responds to market factors during a control (or estimation) window\nUse the coefficients from that regression to estimate how the firm should do during the event window\nSubtract the estimated return from the actual firm return during the event window. Depending on how this difference is aggregated, these are typically buy and hold abnormal returns (bhar) or cumulative abnormla returns (CAR)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"First, to create the table for the estimation window, define an estimation window and an event window:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"event_date = Date(\"2020-09-10\")\nest_start = advancebdays(mkt_data.calendar, event_date, -120)\nest_end = advancebdays(mkt_data.calendar, event_date, -2)\nevent_start = advancebdays(mkt_data.calendar, event_date, -1)\nevent_end = advancebdays(mkt_data.calendar, event_date, 1)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Next, run the estimation regression (the regression automatically selects the correct columns from the data, so it is not necessary to do that beforehand):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"orcl_data = mkt_data[10104, est_start .. est_end]\nrr = quick_reg(orcl_data, @formula(ret ~ mkt + smb + hml))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Then change the table to the event window:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"AbnormalReturns.update_dates!(orcl_data, event_start .. event_end)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now it is easy to run some statistics for the event window:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"bhar(orcl_data, rr) # BHAR based on regression\n\ncar(orcl_data, rr) # CAR based on regression\n\nbhar(orcl_data, \"ret\") # BHAR relative to market return\n\nbh_return(orcl_data, \"ret\") #  Total firm return during event window","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"It is also easy to calculate some statistics for the estimation window:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"var(rr) # Variance of firm returns (similar equation for standard deviation)\n\nbeta(rr) # Firm's market beta\n\nalpha(rr) # Firm's market alpha","category":"page"},{"location":"example/#More-Data-Using-DataFramesMeta","page":"Example","title":"More Data Using DataFramesMeta","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"While the above works well, abnormal returns are often calculated on thousands or more firm-events. Here, I earnings announcements for about 100 firms from March to November 2020:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_events = CSV.File(joinpath(data_dir, \"firm_earnings_announcements.csv\")) |> DataFrame","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Using DataFramesMeta.jl and the @chain macro from Chain.jl, the above steps become:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_events = @chain df_events begin\n    @rtransform(\n        :est_start = advancebdays(mkt_data.calendar, :ea, -120),\n        :est_end = advancebdays(mkt_data.calendar, :ea, -2),\n        :event_start = advancebdays(mkt_data.calendar, :ea, -1),\n        :event_end = advancebdays(mkt_data.calendar, :ea, 1),\n    )\n    @rtransform(:reg = quick_reg(mkt_data[:permno, :est_start .. :est_end], @formula(ret ~ mkt + smb + hml)))\n    @rtransform(\n        :bhar_reg = bhar(mkt_data[:permno, :event_start .. :event_end], :reg),\n        :bhar_simple = bhar(mkt_data[:permno, :event_start .. :event_end], \"ret\", \"mkt\"),\n        :std = std(:reg),\n        :total_ret = bh_return(mkt_data[:permno, :event_start .. :event_end], \"ret\"),\n    )\n    select(Not([:est_start, :est_end, :event_start, :event_end, :reg]))\nend\nshow(df_events) # hide","category":"page"},{"location":"example/#Vectorizing-the-Data","page":"Example","title":"Vectorizing the Data","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"While the above works, and is reasonably fast (Doing a test on 1 million regressions takes about 65 seconds on a Ryzen 5 3600), faster is better.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In particular, this process can be very fast if all the predictor variables in a regression are based on the market data (as they are above). This allows a single RHS matrix to be built and to just select the necessary rows from that matrix. Further, while building the table for each firm is generally fast, if it is only necessary to build it once that is preferred.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To make this possible, request a vector of firm IDs and date starts and ends:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"est_starts = advancebdays.(mkt_data.calendar, df_events.ea, -120)\nest_ends = advancebdays.(mkt_data.calendar, df_events.ea, -2)\nvec_data = mkt_data[df_events.permno, est_starts .. est_ends]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This object can be similarly passed to the above functions, just like a firm level table. The function will iterate through the data and return a vector of results.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"However, the above is rather ugly and is far less flexible (no IDs to update, etc.). A more practical way to use this is to continue using the @chain macro:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_events = @chain df_events begin\n    @rtransform(\n        :est_start = advancebdays(mkt_data.calendar, :ea, -120),\n        :est_end = advancebdays(mkt_data.calendar, :ea, -2),\n        :event_start = advancebdays(mkt_data.calendar, :ea, -1),\n        :event_end = advancebdays(mkt_data.calendar, :ea, 1),\n    )\n    @transform(:reg = quick_reg(mkt_data[:permno, :est_start .. :est_end], @formula(ret ~ mkt + smb + hml)))\n    @transform(\n        :bhar_reg = bhar(mkt_data[:permno, :event_start .. :event_end], :reg),\n        :bhar_simple = bhar(mkt_data[:permno, :event_start .. :event_end], \"ret\", \"mkt\"),\n    )\n    @rtransform(\n        :std = std(:reg),\n        :total_ret = bh_return(mkt_data[:permno, :event_start .. :event_end], \"ret\"),\n    )\n    select(Not([:est_start, :est_end, :event_start, :event_end, :reg]))\nend\nshow(df_events) # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Notice that the only difference between these two @chain macros is that this one uses @transform instead of @rtransform. This sends the entire column vector to the function, and allows for much faster overall results. Those same 1 million regressions now takes just 3 seconds on the same computer.","category":"page"},{"location":"example/#Lag-and-Lead-Operators","page":"Example","title":"Lag and Lead Operators","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Sometimes, you might want to include a lag or lead variable in your regression. This package is designed to handle those cases. For example:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"quick_reg(mkt_data[10104], @formula(ret ~ lag(mkt, 2) + lag(mkt) + mkt + lead(mkt)))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Note that these lag and lead operators will get data from outside the requested period to prevent the sample size from shrinking. For example:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"mkt_data[10104, Date(2020) .. Date(2020, 1, 10), [:ret, :mkt, lag(:mkt)]]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The first value under \"lag(mkt)\" is from 2019-12-31, but this makes sure that a regression or abnormal return has all the data necessary.","category":"page"}]
}
