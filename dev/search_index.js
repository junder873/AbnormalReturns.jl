var documenterSearchIndex = {"docs":
[{"location":"api/#AbnormalReturns-API","page":"API","title":"AbnormalReturns API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This package reexports StatsModels.jl and BusinessDays.jl. See those packages and their respective documentation for methods that they export.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Notable methods from StatsModels.jl:","category":"page"},{"location":"api/","page":"API","title":"API","text":"@formula","category":"page"},{"location":"api/","page":"API","title":"API","text":"Notable methods from BusinessDays.jl:","category":"page"},{"location":"api/","page":"API","title":"API","text":"advancebdays\nbdayscount\ntobday","category":"page"},{"location":"api/#Setting-Up-Data","page":"API","title":"Setting Up Data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MarketData\nAbnormalReturns.all_unique_obs","category":"page"},{"location":"api/#AbnormalReturns.MarketData","page":"API","title":"AbnormalReturns.MarketData","text":"function MarketData(\n    df_market,\n    df_firms;\n    date_col_market=:date,\n    date_col_firms=:date,\n    id_col=:permno,\n    add_intercept_col=true,\n    valuecols_market=nothing,\n    valuecols_firms=nothing\n)\n\nArguments\n\ndf_market: A Tables.jl compatible source that stores market data, indexed by date.   The dates must be a unique set. The column name for the date column is specified   by the keyword argument \"datecolmarket\"\ndf_firms: A Tables.jl compatible source that stores firm data. Each firm must have a   unique set of dates. The column name for the date column is specified   by the keyword argument \"datecolfirms\" and the firm ID column is specified   by the keyword argument \"id_col\"\nvaluecols_market=nothing: If left as nothing, all other columns in df_market are   used as the value columns. These are the columns that are stored in the resulting   dataset. Otherwise a vector of Symbol or String specifying column names.\nvaluecols_firms=nothing: Same as above\nid_col=:permno: The column corresponding to the set of firm IDs in df_firms\nadd_intercept_col=true: Whether to add a column to the data for an intercept (which is   always equal to 1)\n\nMarketData is the main data storage structure. Data is stored for each firm in a Dict, where the data itself is a NamedTuple (names corresponding to column names, such as \"ret\"), and the keys for the Dict corresponding to firm IDs. The MarketData struct also stores overall market data and a calendar of dates.\n\nAny firm data must have a corresponding market data date, so there cannot be a firm return if there is not a market return on that date.\n\nExample\n\ndf_firm = CSV.File(joinpath(data_dir, \"daily_ret.csv\"))\ndf_mkt = CSV.File(joinpath(data_dir, \"mkt_ret.csv\"))\ndf_mkt[!, :mkt] = df_mkt.mktrf .+ df_mkt.rf\nmkt_data = MarketData(\n    df_mkt,\n    df_firm\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#AbnormalReturns.all_unique_obs","page":"API","title":"AbnormalReturns.all_unique_obs","text":"Checks whether each firmid-date pair is unique, assumes that vectors are sorted by firmid then date\n\nReturns true if there is at least one firm_id-date pair repeated, false if all are unique\n\n\n\n\n\n","category":"function"},{"location":"api/#Regression-Related-Methods","page":"API","title":"Regression Related Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"quick_reg\nBasicReg\nalpha\nbeta\nvar\nstd","category":"page"},{"location":"api/#AbnormalReturns.quick_reg","page":"API","title":"AbnormalReturns.quick_reg","text":"quick_reg(\n    data::FixedTable,\n    f::FormulaTerm;\n    minobs::Real=0.8,\n    save_residuals::Bool=false\n)\n\nquick_reg(\n    data::IterateFixedTable,\n    f::FormulaTerm;\n    minobs::Real=0.8,\n    save_residuals::Bool=false\n)\n\nCalculates a linear regression for the supplied data based on the formula (formula from StatsModels.jl). Unless the formula explicitly excludes the intercept (i.e., @formula(y ~ 0 + x)), an intercept is added.\n\nIf data is of the type IterateFixedTable, then the function uses the maximum number of threads on each FixedTable in an optimized way and returns a Vector{BasicReg}.\n\nArguments\n\nminobs::Real: The minimum number of observations to return a completed regression. If less than 1,   the value is used as a percentage relative to the total number of business days in the time period.   Therefore, the default of 0.8 corresponds to at least 80% of the business days over the time period have values.\nsave_residuals::Bool=false: Whether to save the residuals into BasicReg, This can have significant performance implications.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbnormalReturns.BasicReg","page":"API","title":"AbnormalReturns.BasicReg","text":"function BasicReg(\n    resp::AbstractVector,\n    pred::AbstractMatrix,\n    yname::String,\n    xnames::SVector{N, String},\n    f::FormulaTerm{L,R};\n    save_residuals::Bool=false,\n    minobs=1\n)::BasicReg{L,R} where {L,R}\n\nArguments\n\nresp::AbstractVector{Float64}: The \"Y\" or response in a linear regression\npred::AbstractMatrix{Float64}: The \"X\" matrix in a linear regression\nyname::String: The name of the response variable\nxnames::SVector{N, String}: The names of the prediction variables\nf::FormulaTerm{L,R}: A StatsModels.jl formula, saved in the resulting struct\nsave_residuals::Bool=false: Whether or not to save the vector of residuals from   the regression. Note for large numbers of regressions this can significantly slow   down the speed\nminobs::Int=1: The minimum length of the response vector for the regression to   run. The regression will also not run if the length of the response vector is   less than or equal to the number of columns in the prediction matrix.\n\nBasicReg is an intentionally simplistic linear regression. It also attempts to produce a minimum number of allocations if views of vectors are passed.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbnormalReturns.alpha","page":"API","title":"AbnormalReturns.alpha","text":"alpha(rr::RegressionModel, coefname::String...=\"intercept\")\n\n\"alpha\" in respect to the the CAPM model, i.e., the intercept in the model. This is the alpha from the estimation period.\n\nThis function finds the position of the coefficient name provided, defaults to \"intercept\". If the coefname is not in the regression, then this function returns an error.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbnormalReturns.beta","page":"API","title":"AbnormalReturns.beta","text":"beta(rr::RegressionModel, coefname::String...=[\"mkt\", \"mktrf\", \"vwretd\", \"ewretd\"])\n\n\"beta\" in respect to the CAPM model, i.e., the coefficient on the market return minus the risk free rate. This is the beta from the estimation period.\n\nThis function finds the position of the coefficient name provided, defaults to several common market returns. If the coefname is not in the regression, then this function returns an error.\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.var","page":"API","title":"Statistics.var","text":"var[std](rr::Union{AbstractVector{<:RegressionModel}, RegressionModel})\nvar[std](data::Union{IterateFixedTable, FixedTable}; minobs=0.8)\n\nIf a regression model is passed, then this calculates the variance (standard deviation) based on the residual sum of squares divided by the degrees of freedom. A vector of RegressionModel will return the same length of vector results.\n\nIf a FixedTable is passed (or an IterateFixedTable), and that contains only one column, then the variance (standard deviation) is calculated for that column. If it has two columns, then the calculation is based on the difference between the columns.\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.std","page":"API","title":"Statistics.std","text":"See var.\n\n\n\n\n\n","category":"function"},{"location":"api/#Calculation-Functions","page":"API","title":"Calculation Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"bhar\ncar\nbh_return","category":"page"},{"location":"api/#AbnormalReturns.bhar","page":"API","title":"AbnormalReturns.bhar","text":"bhar(\n    data::FixedTable{T, 2};\n    minobs=0.8\n) where {T}\n\nbhar(\n    data::FixedTable,\n    rr::RegressionModel;\n    minobs=0.8\n)\n\nbhar(\n    data::IterateFixedTable{T, 2};\n    minobs=0.8\n) where {T, MNames, FNames}\n\nbhar(\n    data::IterateFixedTable,\n    rrs::AbstractVector{<:BasicReg};\n    minobs=0.8\n)\n\nCalculates the difference between buy and hold returns (also referred to as geometric returns) for a firm and a benchmark. If a regression is passed, then the benchmark is based on the coefficients from that regression and the performance of the benchmarks in the regression. These are sometimes called Fama-French abnormal returns. If no regression is passed, abnormal returns are calculated as the difference between the first and second columns in the FixedTable (second column is typically the benchmark such as the S&P 500 or a value weighted return of all firms).\n\nSimilar to constructing the regression, passing an IterateFixedTable will return a Vector and uses a more optimized method.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbnormalReturns.car","page":"API","title":"AbnormalReturns.car","text":"car(\n    data::FixedTable{T, 2};\n    minobs=0.8\n) where {T}\n\ncar(\n    data::FixedTable,\n    rr::RegressionModel;\n    minobs=0.8\n)\n\ncar(\n    data::IterateFixedTable{T, 2};\n    minobs=0.8\n) where {T, MNames, FNames}\n\ncar(\n    data::IterateFixedTable,\n    rrs::AbstractVector{<:BasicReg};\n    minobs=0.8\n)\n\nCalculates the cumulative returns of a firm over a benchmark (through addition of each return). If a regression is passed, then the benchmark is based on the coefficients from that regression and the performance of the benchmarks in the regression. These are sometimes called Fama-French abnormal returns. If no regression is passed, abnormal returns are calculated as the difference between the first and second columns in the FixedTable (second column is typically the benchmark such as the S&P 500 or a value weighted return of all firms).\n\nSimilar to constructing the regression, passing an IterateFixedTable will return a Vector and uses a more optimized method.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbnormalReturns.bh_return","page":"API","title":"AbnormalReturns.bh_return","text":"Calculates the buy and hold returns (also called geometric return).\n\nThese functions treat missing returns in the period implicitly as a zero return.\n\n\n\n\n\n","category":"function"},{"location":"datastructure/#AbnormalReturns-Data-Structure","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"","category":"section"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"The key to the performance in this package is the underlying data structure. These rely on a combination of BusinessDays.jl and Tables.jl to provide fast access to slices of data based on dates.","category":"page"},{"location":"datastructure/#DataVector","page":"AbnormalReturns Data Structure","title":"DataVector","text":"","category":"section"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"AbnormalReturns.DataVector","category":"page"},{"location":"datastructure/#AbnormalReturns.DataVector","page":"AbnormalReturns Data Structure","title":"AbnormalReturns.DataVector","text":"struct DataVector\n    data::OffsetVector{Float64, Vector{Float64}}\n    missing_bdays::Union{Nothing, OffsetVector{Bool, SparseVector{Bool, Int}}}\n    interval::UnitRange{Int}\n    function DataVector(data, missing_bdays, interval)\n        if missing_bdays !== nothing\n            @assert length(data) == length(missing_bdays) \"Data does not match length of dates or missings\"\n            @assert data.offsets == missing_bdays.offsets\n        end\n        @assert length(interval) == length(data)\n        new(data, missing_bdays, interval)\n    end\nend\n\nDataVector(data::AbstractVector{T}, offset::Int) where {T}\n\nDataVector(data::AbstractVector, d::Date, hc::MarketCalendar)\n\n\n\n\n\n","category":"type"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"These structures provide strongly typed data that is easy to slice based on a range of dates. The data is always stored as Float64, even though it accepts elements of type Missing. In storing the data, Missing values are converted to 0.0, and the missing_bdays is a SparseVector that is true when that value is missing. dates are the minimum and maximum dates for the data.","category":"page"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"Data in a DataVector is stored in an OffsetVector from OffsetArrays.jl, but this data is rarely accessed directly.","category":"page"},{"location":"datastructure/#MarketData","page":"AbnormalReturns Data Structure","title":"MarketData","text":"","category":"section"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"    struct MarketData{T}\n        calendar::MarketCalendar\n        marketdata::Dict{Symbol, DataVector} # column names as symbols\n        firmdata::Dict{T, Dict{Symbol, DataVector}} # data stored by firm id and then by column name as symbol\n    end","category":"page"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"This struct is made up of a set of DataVector. The main purpose of this is to provide efficient storage of the underlying data along with the calendar so that dates are easily translated to access the underlying data.","category":"page"},{"location":"datastructure/#FixedTable","page":"AbnormalReturns Data Structure","title":"FixedTable","text":"","category":"section"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"FixedTable","category":"page"},{"location":"datastructure/#AbnormalReturns.FixedTable","page":"AbnormalReturns Data Structure","title":"AbnormalReturns.FixedTable","text":"struct FixedTable{N, T<:AbstractFloat, AV <: AbstractVector{T}, CL<:Union{Symbol, String}} <: AbstractMatrix{T}\n    data::SVector{N, AV}\n    cols::SVector{N, CL}\n    req_length::Int\n    function FixedTable(xs::SVector{N, AV}, cols::SVector{N, CL}, req_length=0) where {T, N, AV<:AbstractVector{T}, CL}\n        new{N, T, AV, CL}(xs, cols, req_length)\n    end\nend\n\nThis provides a fixed-width interface that is designed to allow quick access (either through accessing a column number data[:, 1] or accessing a column name data[:, :a]). req_length is an optional parameter that specifies the length that a user originally requested, which is used in later functions to determine if the FixedTable has too few rows.\n\n\n\n\n\n","category":"type"},{"location":"datastructure/#Market-Calendar","page":"AbnormalReturns Data Structure","title":"Market Calendar","text":"","category":"section"},{"location":"datastructure/","page":"AbnormalReturns Data Structure","title":"AbnormalReturns Data Structure","text":"AbnormalReturns.MarketCalendar","category":"page"},{"location":"datastructure/#AbnormalReturns.MarketCalendar","page":"AbnormalReturns Data Structure","title":"AbnormalReturns.MarketCalendar","text":"MarketCalendar\n\nbdays: a vector of business days\ndtmin: minimum date allowed to check for bdays in bdays set. Defaults to min(bdays...).\ndtmax: maximum date allowed to check for bdays in bdays set. Defaults to max(bdays...).\ncache: instance of HolidayCalendarCache.\n\n\n\n\n\n","category":"type"},{"location":"#AbnormalReturns-Documentation","page":"Introduction","title":"AbnormalReturns Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides functionality for getting slices of firm and market return data and running firm-specific regressions commonly used to calculate abnormal stock returns (actual stock return minus a benchmark). These are common in event studies in finance and economics and often require running a large number of regressions on different slices of firm and market data.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Most of the documentation is currently in the example.","category":"page"},{"location":"#Motivation","page":"Introduction","title":"Motivation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"When estimating abnormal returns, it is common to estimate how the firm's return typically responds during an estimation window and use those predicted results in an event window:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The exact length of the estimation and event windows varies, but are typically about 150 and 3-5, respectively. The estimation is typically is a linear regression of firm specific return on market-wide factors.","category":"page"},{"location":"#The-Problem","page":"Introduction","title":"The Problem","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Estimating abnormal returns requires getting two separate slices of data (for the estimation window and event window) for each firm-event. This is relatively trivial for small datasets, but abnormal returns are often calculated for a large number of events. For example, there are over 600,000 firm earnings announcements since 1990.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Generally, creating the dataset is done through a range join (e.g., gather all firm data between the start and end of the estimation window), which is often time consuming and/or creates huge datasets.","category":"page"},{"location":"#This-Package","page":"Introduction","title":"This Package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package uses a custom data structure to avoid repeating the data. The data structure is built on BusinessDays.jl, making it easy to get a slice of data between two dates. It also implements threaded solutions to make the regressions and aggregation as fast as possible.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In a benchmark on 1 million firm events, it runs all the regressions in under 3 seconds. In a larger benchmark with two different models (so 2 million regressions) and calculating abnormal returns for the events, along with other basic statistics, it takes less than 9 seconds on a Ryzen 5 3600.","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package would not be possible without BusinessDays.jl, which is used for all of the date operations in this package and StatsModels.jl, which provides an incredible @formula macro and the functionality that comes with that.","category":"page"},{"location":"example/#Example","page":"Example","title":"AbnormalReturns Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"As a quick example:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"data_dir = joinpath(\"..\", \"..\", \"test\", \"data\") # hide\nusing CSV, DataFramesMeta, Dates, AbnormalReturns\n\ndf_firm = CSV.File(joinpath(data_dir, \"daily_ret.csv\")) |> DataFrame\ndf_mkt = CSV.File(joinpath(data_dir, \"mkt_ret.csv\")) |> DataFrame\ndf_mkt[!, :mkt] = df_mkt.mktrf .+ df_mkt.rf\ndf_events = CSV.File(joinpath(data_dir, \"firm_earnings_announcements.csv\")) |> DataFrame\nmkt_data = MarketData(\n    df_mkt,\n    df_firm\n)\ndf_events = @chain df_events begin\n    @rtransform(\n        :est_start = advancebdays(mkt_data.calendar, :ea, -120),\n        :est_end = advancebdays(mkt_data.calendar, :ea, -2),\n        :event_start = advancebdays(mkt_data.calendar, :ea, -1),\n        :event_end = advancebdays(mkt_data.calendar, :ea, 1),\n    )\n    @transform(:reg = quick_reg(mkt_data[:permno, :est_start .. :est_end], @formula(ret ~ mkt + smb + hml)))\n    @transform(\n        :bhar_reg = bhar(mkt_data[:permno, :event_start .. :event_end], :reg),\n        :bhar_simple = bhar(mkt_data[:permno, :event_start .. :event_end, [\"ret\", \"mkt\"]]),\n        :car_reg = car(mkt_data[:permno, :event_start .. :event_end], :reg),\n        :car_simple = car(mkt_data[:permno, :event_start .. :event_end, [\"ret\", \"mkt\"]]),\n        :total_ret = bh_return(mkt_data[:permno, :event_start .. :event_end, [\"ret\"]]),\n        :total_mkt_ret = bh_return(mkt_data[:permno, :event_start .. :event_end, [\"mkt\"]]),\n    )\n    @rtransform(\n        :std = std(:reg),\n        :var = var(:reg),\n\n    )\n    select(Not([:est_start, :est_end, :event_start, :event_end, :reg]))\n    # columns eliminated to save space:\n    select(Not([:car_reg, :car_simple, :var, :total_mkt_ret]))\nend\nshow(df_events) # hide","category":"page"},{"location":"example/#Data","page":"Example","title":"Data","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"For the basic data, this uses the files in the test folder of this package (\"test\\data\"). The \"daily_ret.csv\" file is a selection of firm returns, while \"mkt_ret.csv\" includes the average market return along with some Fama-French factor returns, you can download similar Fama-French data from here or from FamaFrenchData.jl and stock market data from AlphaVantage.jl or WRDSMerger.jl (requires access to the WRDS database).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The firm data uses \"Permno\" to identify a stock. This package will work with other identifiers, as long as the identifier-date pair is unique. However, Integers and Symbols will often be fastest (as opposed to String identifiers).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"data_dir = joinpath(\"..\", \"..\", \"test\", \"data\") # hide\nusing CSV, DataFramesMeta, Dates, AbnormalReturns","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Load the firm data:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_firm = CSV.File(joinpath(data_dir, \"daily_ret.csv\")) |> DataFrame\nshow(df_firm) # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"and the market data:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_mkt = CSV.File(joinpath(data_dir, \"mkt_ret.csv\")) |> DataFrame\nshow(df_mkt) # hide","category":"page"},{"location":"example/#Arranging-and-Accessing-the-Data","page":"Example","title":"Arranging and Accessing the Data","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Next, load the data into a MarketData object:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"mkt_data = MarketData(\n    df_mkt,\n    df_firm;\n    id_col=:permno,# default\n    date_col_firms=:date,# default\n    date_col_market=:date,# default\n    add_intercept_col=true,# default\n    valuecols_firms=[:ret],# defaults to nothing, in which case\n    # all columns other than id and date are used\n    valuecols_market=[:mktrf, :rf, :smb, :hml, :umd]# defaults to\n    # nothing, in which case all columns other than date are used\n)\nshow(mkt_data) # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"note: Note\nFor performance, especially when loading large datasets of firm data, it is best to make sure the firm dataframe is presorted by ID then Date.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This object rearranges the data so it can be quickly accessed later. The mkt_data now contains 3 things:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"A BusinessDays.jl calendar that exactly matches the days loaded in the market data.\nEach column of the df_mkt stored\nEach column of the df_firm stored in a Dict for each firm.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Data is accessed on a by firm basis, for a given date range and specific columns. For example, say you wanted to get the data for Oracle (ORCL) (\"Permno\" of 10104), for a specific date (using IntervalSets.jl) and set of columns:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"orcl_data = mkt_data[10104, Date(2020) .. Date(2020, 6, 30), [:ret, :mktrf, :smb]]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Sometimes it is helpful to add a new column (either for convenience or performance reasons, discussed later). To do so, this package borrows the transform! function from DataFrames.jl, using a formula where the left side is the column that is created:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"transform!(mkt_data, @formula(mkt ~ mktrf + rf));","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"It is also easy to specify the columns as a formula from StatsModels.jl. This allows for arbitrary functions, interactions and lags/leads:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"orcl_data = mkt_data[10104, Date(2020) .. Date(2020, 6, 30), @formula(ret ~ mkt + lag(mkt) + log1p(smb) * hml)]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"note: Note\nWhile interactions and arbitrary functions are supported, they can significantly slow down performance since a new vector is allocated in each call. Therefore, it is generally recommended to create a new pice of data by calling transform! on the dataset to create the new columns. This advice does not apply to lag/lead terms since those do not need to allocate a new column.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The data returned by accessing mkt_data is a FixedTable, which is essentially a matrix with a fixed width (useful for multiplication and returning a StaticMatrix from StaticArrays.jl). Access into this data is done either by a slice as you would any other matrix:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"orcl_data[:, 1]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Or via the names used to access it in the first place:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"orcl_data[:, :mkt]","category":"page"},{"location":"example/#Estimating-Regressions","page":"Example","title":"Estimating Regressions","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The main goal of this package is quickly running regressions for firm events. The example used here is a firm's earnings announcement. Starting with one example, Oracle announced its Q3 2020 earnings on 2020-9-10. Calculating abnormal returns typically follows three steps:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Estimate how the firm typically responds to market factors during a control (or estimation) window\nUse the coefficients from that regression to estimate how the firm should do during the event window\nSubtract the estimated return from the actual firm return during the event window. Depending on how this difference is aggregated, these are typically buy and hold abnormal returns (bhar) or cumulative abnormla returns (CAR)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"First, to create the table for the estimation window, define an estimation window and an event window:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"event_date = Date(\"2020-09-10\")\nest_start = advancebdays(mkt_data.calendar, event_date, -120)\nest_end = advancebdays(mkt_data.calendar, event_date, -2)\nevent_start = advancebdays(mkt_data.calendar, event_date, -1)\nevent_end = advancebdays(mkt_data.calendar, event_date, 1)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Next, run the estimation regression (the regression automatically selects the correct columns from the data, so it is not necessary to do that beforehand):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"orcl_data = mkt_data[10104, est_start .. est_end]\nrr = quick_reg(orcl_data, @formula(ret ~ mkt + smb + hml))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Then get the data for the event window:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"orcl_data = mkt_data[10104, event_start .. event_end];","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now it is easy to run some statistics for the event window:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"bhar(orcl_data, rr) # BHAR based on regression\n\ncar(orcl_data, rr) # CAR based on regression","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"It is also easy to calculate some statistics for the estimation window:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"var(rr) # Variance of firm returns (similar equation for standard deviation)\n\nbeta(rr) # Firm's market beta\n\nalpha(rr) # Firm's market alpha","category":"page"},{"location":"example/#More-Data-Using-DataFramesMeta","page":"Example","title":"More Data Using DataFramesMeta","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"While the above works well, abnormal returns are often calculated on thousands or more firm-events. Here, I use earnings announcements for about 100 firms from March to November 2020:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_events = CSV.File(joinpath(data_dir, \"firm_earnings_announcements.csv\")) |> DataFrame","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Using DataFramesMeta.jl and the @chain macro from Chain.jl, the above steps become:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_events = @chain df_events begin\n    @rtransform(\n        :est_start = advancebdays(mkt_data.calendar, :ea, -120),\n        :est_end = advancebdays(mkt_data.calendar, :ea, -2),\n        :event_start = advancebdays(mkt_data.calendar, :ea, -1),\n        :event_end = advancebdays(mkt_data.calendar, :ea, 1),\n    )\n    @rtransform(:reg = quick_reg(mkt_data[:permno, :est_start .. :est_end], @formula(ret ~ mkt + smb + hml)))\n    @rtransform(\n        :bhar_reg = bhar(mkt_data[:permno, :event_start .. :event_end], :reg),\n        :bhar_simple = bhar(mkt_data[:permno, :event_start .. :event_end, [\"ret\", \"mkt\"]]),\n        :std = std(:reg),\n        :total_ret = bh_return(mkt_data[:permno, :event_start .. :event_end, [\"ret\"]]),\n    )\n    select(Not([:est_start, :est_end, :event_start, :event_end, :reg]))\nend\nshow(df_events) # hide","category":"page"},{"location":"example/#Vectorizing-the-Data","page":"Example","title":"Vectorizing the Data","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"While the above works, and is reasonably fast (Doing a test on 1 million regressions takes about 26 seconds on a Ryzen 7 5700X), faster is better.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In particular, a significant reason the above is slow method is that the formula is parsed for each iteration. If the formula is the same for all of the cases, it is better if it is simply parsed once. Therefore, it is optimal to do as much as possible using vectors.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To make this possible, this package provides a type IterateFixedTable which will return a FixedTable based on a supplied set of ids, dates and columns (or formula as above):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"est_starts = advancebdays.(mkt_data.calendar, df_events.ea, -120)\nest_ends = advancebdays.(mkt_data.calendar, df_events.ea, -2)\nvec_data = mkt_data[df_events.permno, est_starts .. est_ends, [:ret, :mkt, :smb]]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Each element of vec_data is then easily accessible by an integer or can be looped over in a for loop:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# for x in vec_data\n#     x\n# end\n# or\nvec_data[10]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This object can be similarly passed to the above functions, just like a firm level table. The function will iterate through the data and return a vector of results.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"However, the above is rather ugly. A more practical way to use this is to continue using the @chain macro:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"df_events = @chain df_events begin\n    @rtransform(\n        :est_start = advancebdays(mkt_data.calendar, :ea, -120),\n        :est_end = advancebdays(mkt_data.calendar, :ea, -2),\n        :event_start = advancebdays(mkt_data.calendar, :ea, -1),\n        :event_end = advancebdays(mkt_data.calendar, :ea, 1),\n    )\n    @transform(:reg = quick_reg(mkt_data[:permno, :est_start .. :est_end], @formula(ret ~ mkt + smb + hml)))\n    @transform(\n        :bhar_reg = bhar(mkt_data[:permno, :event_start .. :event_end], :reg),\n        :bhar_simple = bhar(mkt_data[:permno, :event_start .. :event_end, [\"ret\", \"mkt\"]]),\n    )\n    @transform(\n        :std = std.(:reg),\n        :total_ret = bh_return(mkt_data[:permno, :event_start .. :event_end, [\"ret\"]]),\n    )\n    select(Not([:est_start, :est_end, :event_start, :event_end, :reg]))\nend\nshow(df_events) # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Notice that the only difference between these two @chain macros is that this one uses @transform instead of @rtransform. This sends the entire column vector to the function, and allows for much faster overall results. Those same 1 million regressions now takes just 0.44 seconds on the same computer.","category":"page"}]
}
